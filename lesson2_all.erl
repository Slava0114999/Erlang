-module(lesson2_all).
-export([last/1,but_last/1,element_at/2,len/1,reverse/1,is_palindrome/1,flatten/1,lj/2]).

%​ P01 (*) Найти последний элемент списка:
last([H])->
    H;
last([_H|T])->
    last(T).

% ​P02 (*) Найти два последних элемента списка:
but_last([_,_]=X)->
    X;
but_last([_H|T])->
    but_last(T).

% ​P03 (*) Найти N-й элемент списка:
element_at([H,_T],1)->
    H;
element_at([_H|T],N)->
    element_at(T,N-1);
element_at([],_)->
    undefined.

%​ P04 (*) Посчитать количество элементов списка:
% Хвостова рекурсія:
len(L)->
    len(L,0).
len([],N)->
    N;
len([_H|T],N)->
    len(T,N+1).
% ? Що зміниться від перестановки останніх двох клоз: 
% ?       len([_H|T],N)->
% ?           len(T,N+1);
% ?       len([],N)->
% ?           N.



% Боді рекурсія:
%len([])->
%    0;
%len([_H|T])->
%    1+len(T).

%​ P05 (*) Перевернуть список:
reverse(L)->
    reverse(L,[]).
reverse([],R)->
    R;
reverse([H|T],R)->
    reverse(T,[H|R]).

% ​P06 (*) Определить, является ли список палиндромом:
is_palindrome(L)->
    reverse(L)==L.

% P07 (**) Выровнять структуру с вложеными списками:
flatten(L)->
    flatten(L,[]).
flatten([],F)->
    F;
flatten([H|T],F)->
    flatten(T,[F++H]).
%lesson2_all:flatten([a,[],[b,[c,d],e]]).  // [[[a],b,[c,d],e]] ? Як розбити вкладені списки ?




% P08 (**) Удалить последовательно следующие дубликаты:
% P09 (**) Запаковать последовательно следующие дубликаты во вложеные списки:
% ​P10 (**) Закодировать список с использованием алгоритма RLE:
% ​P11 (**) Закодировать список с использованием модифицированого алгоритма RLE:
% ​P12 (**) Написать декодер для модифицированого алгоритма RLE:
% ​P13 (**) Написать декодер для стандартного алгоритма RLE:
% P14 (*) Написать дубликатор всех элементов входящего списка:
% ​P15 (**) Написать функцию-репликатор всех элементов входящего списка:

